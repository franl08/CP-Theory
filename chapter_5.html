<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Aceleradores de Computação: GPU e CUDA - Teóricas de CP</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Apresentação da UC</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Otimização de Código Sequencial</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Hierarquia de Memória</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Paralelismo de Dados e Multithreading em Uniprocessadores</a></li><li class="chapter-item expanded "><a href="chapter_5.html" class="active"><strong aria-hidden="true">5.</strong> Aceleradores de Computação: GPU e CUDA</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Introdução à Programação com Memória Partilhada</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Programação Paralela com Memória Partilhada</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> Medição e Otimização de Desempenho em Memória Partilhada</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> Programação em Memória Distribuída com Passagem de Mensagens</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> Algoritmos Paralelos (Sorting)</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> De Multicore para Manycore</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> Sistemas Top HPC nas listas do TOP500</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Teóricas de CP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="aceleradores-de-computação-gpu-e-cuda"><a class="header" href="#aceleradores-de-computação-gpu-e-cuda">Aceleradores de Computação: GPU e CUDA</a></h1>
<h2 id="aceleradores-de-computação"><a class="header" href="#aceleradores-de-computação">Aceleradores de Computação</a></h2>
<ul>
<li>O melhor acelerador para <em>number crunching</em> ou para computação intensiva de vetores/matrizes é a GPU;</li>
<li>Temos ainda outros aceleradores comuns:
<ul>
<li><strong>DSP</strong>: <em>Digital Signal Processor</em>;
<ul>
<li>Usado, maioritariamente, em equipamentos de telecomunicações.</li>
</ul>
</li>
<li><strong>TPU</strong>: <em>Tensor Unit Processing Units</em>;
<ul>
<li>Otimizado para operações com tensores (vetores e matrizes n-dimensionais), popularizado em aplicações AI, nomeadamente para condução autónoma.</li>
</ul>
</li>
<li><strong>FPGA</strong>: <em>Field Programmable Gate Arrays</em>.
<ul>
<li><em>Hardware</em>/<em>Software</em> reconfigurável;</li>
<li>Pode ser configurado em <em>runtime</em> de forma a comportar-se como uma dada especificação.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="graphical-processing-units-gpu"><a class="header" href="#graphical-processing-units-gpu"><em>Graphical Processing Units</em> (GPU)</a></h2>
<ul>
<li>Ideia base:
<ul>
<li>Modelos de execução heterogéneos;
<ul>
<li>A CPU será o <em>host</em> e a GPU o <em>device</em>.</li>
</ul>
</li>
<li>Deve desenvolver-se um programa numa linguagem semelhante a C para a GPU;</li>
<li>Une todas as formas de paralelismo da GPU como uma <em>thread</em> CUDA;</li>
<li>O modelo de programação segue o SIMT (<em>Single Instruction Multiple Thread</em>).</li>
</ul>
</li>
</ul>
<h3 id="arquitetura-de-uma-gpu-da-nvidia"><a class="header" href="#arquitetura-de-uma-gpu-da-nvidia">Arquitetura de uma GPU da Nvidia</a></h3>
<ul>
<li>Semelhanças com máquinas vetoriais:
<ul>
<li>Trabalha bem com problemas de paralelismo ao nível dos dados;</li>
<li>Aplica o <em>scatter-gather</em> às transferências;</li>
<li>Aplica <em>masks</em> aos registos;</li>
<li>Tem grandes ficheiros de registo.</li>
</ul>
</li>
<li>Diferenças:
<ul>
<li>Não tem um processador escalar;</li>
<li>Utiliza <em>multithreading</em> de forma a esconder a latência da memória;</li>
<li>Tem múltiplas unidades funcionais, mas poucas unidades em <em>pipeline</em>, trabalhando como um processador vetorial.</li>
</ul>
</li>
</ul>
<h3 id="terminologia"><a class="header" href="#terminologia">Terminologia</a></h3>
<ul>
<li>Cada <em>thread</em> está limitada a 64 registos;</li>
<li>Grupos de 32 <em>threads</em> estão combinados numa <em>thread</em> SIMD, também chamada <em>warp</em>;
<ul>
<li>Mapeada em 16 pistas físicas.</li>
</ul>
</li>
<li>Até 32 <em>warps</em> são agendados num único processador SIMD (SM);
<ul>
<li>Cada <em>warp</em> terá o seu próprio PC;</li>
<li>O agente responsável pelo agendamento das <em>threads</em> utiliza um <em>scoreboard</em> de forma a expedir as <em>threads</em>;</li>
<li>Por definição, não existem dependências de dados entre <em>warps</em>;</li>
<li>Ao expedir os <em>warps</em> para <em>pipelines</em>, esconderá a latência da memória.</li>
</ul>
</li>
<li>Cada processador SIMD (SM):
<ul>
<li>Tem 32 pistas SIMD;</li>
<li>É largo e mais raso quando comparado com processadores vetoriais.</li>
</ul>
</li>
</ul>
<h3 id="estruturas-de-memória-de-uma-gpu-da-nvidia"><a class="header" href="#estruturas-de-memória-de-uma-gpu-da-nvidia">Estruturas de Memória de uma GPU da Nvidia</a></h3>
<ul>
<li>Cada pista SIMD tem uma secção privada de um <em>off-chip</em> DRAM;
<ul>
<li>&quot;Memória Privada&quot; (na terminologia da Nvidia, <em>Local Memory</em>);</li>
<li>Contém um <em>stack frame</em>, <em>spilling registers</em> e variáveis privadas.</li>
</ul>
</li>
<li>Cada processador SIMD <em>multithreaded</em> (na terminologia da Nvidia, <em>SM</em>) também possui memória local (na termionologia da Nvidia, <em>Shared Memory</em>);
<ul>
<li>Partilhada pelas pistas SIMD/<em>threads</em> num dado bloco.</li>
</ul>
</li>
<li>A memória partilhada pelos processadores SIMD é memória da GPU e o <em>off-chip</em> DRAM (na terminologia da Nvidia, <em>Global Memory</em>).
<ul>
<li>O <em>host</em> poderá ler e escrever na memória da GPU.</li>
</ul>
</li>
</ul>
<h3 id="inovações-da-arquitetura-pascal-maio-2016"><a class="header" href="#inovações-da-arquitetura-pascal-maio-2016">Inovações da Arquitetura Pascal (maio 2016)</a></h3>
<ul>
<li>Cada processador SIMD tem:
<ul>
<li>Dois ou 4 agentes de agendamento de <em>threads</em> SIMD, duas unidades de expedição de instruções;</li>
<li>4 pistas de 16 SIMD, 16 unidades de <em>load-store</em> e 16 unidades de funções especiais;</li>
<li>2 <em>threads</em> de instruções SIMD são agendadas a cada 2 <em>clock cycles</em>.</li>
</ul>
</li>
<li>Introdução de:
<ul>
<li><em>Fast single-precision</em>;</li>
<li><em>Doube-precision</em>;</li>
<li><em>Half-precision</em>.</li>
</ul>
</li>
<li><em>High Bandwith Memory 2</em> (HBM2) com 732 GB/s;</li>
<li><em>NVLink</em> entre múltiplas GPUs (20 GB/s em cada direção);</li>
<li>Memória virtual e <em>paging support</em> unificados.</li>
</ul>
<h2 id="arquiteturas-vetoriais-vs-gpus"><a class="header" href="#arquiteturas-vetoriais-vs-gpus">Arquiteturas Vetoriais <em>vs</em> GPUs</a></h2>
<ul>
<li>Processador SIMD análogo ao processador vetorial, ambos têm MIMD;</li>
<li>Registos:
<ul>
<li>O ficheiro de registo RV64V é capaz de manter vetores inteiros, enquanto que a GPU irá distribuir os vetores em registos das pistas SIMD;</li>
<li>O RV64V tem 32 registos de vetores de 32 elementos (total de 1024 elementos), já a GPU tem 256 registos com 32 elementos (total de 8000 elementos);</li>
<li>RV64V tem 2 a 8 pistas com o tamanho do vetor a ser de 32, e o <em>chime</em> terá entre 4 a 16 ciclos, já no proocessador SIMD o <em>chime</em> terá 2 a 4 ciclos;
<ul>
<li><em>quick reminder</em>: o <em>chime</em> é uma unidade de tempo que demora a executar um <em>convoy</em>;
<ul>
<li><em>convoy</em>: um conjunto de instruções vetoriais que, potencialmente, poderá começar a execução em conjunto num período de relógio.</li>
</ul>
</li>
</ul>
</li>
<li>O <em>loop</em> vetorizado da GPU é uma grelha;</li>
<li>Todas as instruções de leitura da GPU são <em>gather</em> e todas as instruções de guardar são <em>scatter</em>.</li>
</ul>
</li>
</ul>
<h2 id="arquiteturas-simd-vs-gpus"><a class="header" href="#arquiteturas-simd-vs-gpus">Arquiteturas SIMD <em>vs</em> GPUs</a></h2>
<ul>
<li>As GPUs possuem mais pistas SIMD;</li>
<li>As GPUs têm <em>hardware</em> para suportar mais <em>threads</em>;</li>
<li>Ambas têm um rácio de 2:1 entre o desempenho entre <em>double-precision</em> e <em>single-precision</em>;</li>
<li>Ambas têm endereços de 64 <em>bits</em>, mas as GPUs têm menor memória;</li>
<li>Arquiteturas SIMD não têm suporte para instruções <em>scatter-gather</em>.</li>
</ul>
<h2 id="modelo-de-programação-cuda"><a class="header" href="#modelo-de-programação-cuda">Modelo de programação CUDA</a></h2>
<ul>
<li><em>Compute Unified Device Architecture</em>;</li>
<li>Desenhado para:
<ul>
<li><em>hosts</em> com CPUs <em>multicore</em> acoplados a dispositivos <em>many-core</em> onde:
<ul>
<li>os dispositivos têm um grande paralelismo SIMD/SIMT;</li>
<li>o <em>host</em> e o dispositivo não partilham memória.</li>
</ul>
</li>
</ul>
</li>
<li>Providencia:
<ul>
<li>uma abstração de <em>threads</em> de forma a lidar com o SIMD;</li>
<li>sincronização e partilha de dados entre pequenos grupos de <em>threads</em>.</li>
</ul>
</li>
<li>Os programas em CUDA são escritos em C com extensões;</li>
<li>O OpenCL é inspirado no CUDA, mas o <em>hardware</em> e o <em>software</em> não têm um produtor específico.
<ul>
<li>O modelo de programação é, essencialmente, idêntico.</li>
</ul>
</li>
</ul>
<h3 id="dispositivos-cuda-e-threads"><a class="header" href="#dispositivos-cuda-e-threads">Dispositivos CUDA e <em>Threads</em></a></h3>
<ul>
<li>Um dispositivo de computação:
<ul>
<li>é um co-processador para a CPU ou <em>host</em>;</li>
<li>tem a sua própria DRAM (chamada, <em>device memory</em>);</li>
<li>corre múltiplas <em>threads</em> em paralelo;</li>
<li>tipicamente, é uma GPU, mas também ser qualquer outro tipo de dispositivo de processamento em paralelo.</li>
</ul>
</li>
<li>As porções de dados paralelos de uma aplicação são expressas com <em>kernels</em> do dispostivo que irão correr em múltiplas <em>threads</em> (SIMT);</li>
<li>Diferenças entre <em>threads</em> de GPU e <em>threads</em> de CPU:
<ul>
<li><em>threads</em> de GPU são extremamente leves;
<ul>
<li>pouco <em>overhead</em> de criação, mas requerem um grande banco de registos.</li>
</ul>
</li>
<li>a GPU precisa de milhares de <em>threads</em> para apresentar a sua eficiência mãxima;
<ul>
<li>por outro lado, os CPUs <em>multicore</em> precisam de poucas.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="modelo-básico-de-cuda-single-program-multiple-data-spmd"><a class="header" href="#modelo-básico-de-cuda-single-program-multiple-data-spmd">Modelo básico de CUDA: <em>Single Program, Multiple Data</em> (SPMD)</a></h3>
<ul>
<li>CUDA integrado na CPU + aplicação de um programa em C na GPU;
<ul>
<li>Código sequencial C executa na CPU;</li>
<li><em>Kernel</em> paralelo C executa em blocos de <em>threads</em> na GPU.</li>
</ul>
</li>
</ul>
<h3 id="spmd--simtsimd"><a class="header" href="#spmd--simtsimd">SPMD + SIMT/SIMD</a></h3>
<ul>
<li><strong>Hierarquia</strong>:
<ul>
<li>Dispostivo \( \rightarrow \) Grelhas;</li>
<li>Grelhas \( \rightarrow \) Blocos;</li>
<li>Blocos \( \rightarrow \) <em>Warps</em>;</li>
<li><em>Warps</em> \( \rightarrow \) <em>Threads</em>.</li>
</ul>
</li>
<li>Um único <em>kernel</em> corre em múltiplos blocos (SPMD);</li>
<li>As <em>threads</em> de um <em>warp</em> são executadas numa forma <em>lock-step</em> denominada <em>single instruction, multiple thread</em> (SIMT);</li>
<li>Instruções singulares são executas em múltiplas <em>threads</em> (SIMD);
<ul>
<li>O tamanho do <em>warp</em> define a granularidade do SIMD (32 <em>threads</em>).</li>
</ul>
</li>
<li>A sincronização dentro de um bloco utiliza a memória partilhada.</li>
</ul>
<h3 id="grelha-computacional-block-ids-e-thread-ids"><a class="header" href="#grelha-computacional-block-ids-e-thread-ids">Grelha Computacional: <em>Block IDs</em> e <em>Thread IDs</em></a></h3>
<ul>
<li>Um <em>kernel</em> corre numa grelha computacional de blocos de <em>threads</em>;
<ul>
<li>As <em>threads</em> utilizam memória global partilhada.</li>
</ul>
</li>
<li>Cada <em>thread</em> utiliza IDs para decidir em que dados deve trabalhar;
<ul>
<li>ID do bloco: 1D ou 2D;</li>
<li>ID da <em>thread</em>: 1D, 2D ou 3D.</li>
</ul>
</li>
<li>Um bloco de <em>threads</em> é um <em>batch</em> de <em>threads</em> que podem cooperar entre si:
<ul>
<li>Sincronizam a sua execução com uma barreira;</li>
<li>Partilham dados de forma eficiente através de memória partilhada de baixa latência;</li>
<li>Duas <em>threads</em> de dois diferentes blocos não podem cooperar entre si.</li>
</ul>
</li>
</ul>
<h3 id="terminologia-e-terminologia-da-nvidia"><a class="header" href="#terminologia-e-terminologia-da-nvidia">Terminologia (e terminologia da Nvidia)</a></h3>
<ul>
<li><em>Threads</em> de instruções SIMD (<em>warps</em>);
<ul>
<li>Cada uma tem o seu próprio <em>Instruction Pointer</em> (até 48/64 por processador SIMD);</li>
<li>O agente responsável por agendar <em>threads</em> utiliza <em>scoreboards</em> para as expedir;</li>
<li>Não existem dependências de dados entre <em>threads</em>;</li>
<li>As <em>threads</em> são organizadas em blocos e executadas em grupos de 32 <em>threads</em> (bloco de <em>threads</em>).
<ul>
<li>Os blocos estão organizados numa grelha.</li>
</ul>
</li>
</ul>
</li>
<li>O agente responsável por agendar os <em>thread blocks</em> agenda-os para os processadores SIMD (<em>Streaming Multiprocessors</em>);</li>
<li>Em cada processador SIMD:
<ul>
<li>32 pistas SIMD (<em>thread processors</em>);</li>
<li>Mais largos e rasos quando comparados a processadores vetoriais.</li>
</ul>
</li>
</ul>
<h3 id="bloco-de-threads-cuda"><a class="header" href="#bloco-de-threads-cuda">Bloco de <em>Threads</em> CUDA</a></h3>
<ul>
<li>O programador declara o bloco (de <em>threads</em>):
<ul>
<li>tamanho irá variar entre 1 a 512 <em>threads</em> concorrentes;</li>
<li>terá um formato 1D, 2D ou 3D;</li>
<li>dimensões dos blocos em <em>threads</em>.</li>
</ul>
</li>
<li>Todos as <em>threads</em> num bloco executam o mesmo programa de <em>thread</em>;</li>
<li>As <em>threads</em> partilham os dados e sincronizam-se enquanto partilham o seu trabalho;</li>
<li>As <em>threads</em> têm números de identificação dentro de um bloco;</li>
<li>Os programas de <em>threads</em> utilizam os <em>thread ID</em> de forma a selecionar os trabalhos e endereçar os dados partilhados.</li>
</ul>
<pre><code class="language-c">float x = input[threadID];
float y = func(x);
output[threadID] = y;
</code></pre>
<h3 id="partilha-de-memória-partilhada"><a class="header" href="#partilha-de-memória-partilhada">Partilha de memória partilhada</a></h3>
<ul>
<li>Memória Local (por <em>thread</em>):
<ul>
<li>Privada por <em>thread</em>;</li>
<li>Variáveis automáticas, <em>register spill</em>.
<ul>
<li><em>quick reminder</em>: ocorre <em>register spill</em> quando os registos da CPU estão cheios, pelo que o conteúdo tem de ser, temporariamente, guardado em memória.</li>
</ul>
</li>
</ul>
</li>
<li>Memória Partilhada (por bloco):
<ul>
<li>Partilhada por <em>threads</em> no mesmo bloco;</li>
<li>Comunicação inter-<em>threads</em>.</li>
</ul>
</li>
<li>Memória Global (por aplicação):
<ul>
<li>Partilhada por todas as <em>threads</em>;</li>
<li>Comunicação inter-grelhas.</li>
</ul>
</li>
</ul>
<h3 id="overview-do-modelo-de-memória-cuda"><a class="header" href="#overview-do-modelo-de-memória-cuda"><em>Overview</em> do modelo de memória CUDA</a></h3>
<ul>
<li>Cada <em>thread</em> pode:
<ul>
<li>Ler/Escrever <em>per-thread</em> em registos;</li>
<li>Ler/Escrever <em>per-thread</em> em memória local;</li>
<li>Ler/Escrever <em>per-block</em> em memória partilhada;</li>
<li>Ler/Escrever <em>per-grid</em> em memória global;</li>
<li>Ler apenas <em>per-grid</em> em memória constante;</li>
<li>Ler apenas <em>per-grid</em> em memória de textura.</li>
</ul>
</li>
<li>O <em>host</em> pode ler e escrever em memória global, constante ou de textura.</li>
</ul>
<h3 id="implementação-em-hardware-arquitetura-de-memória"><a class="header" href="#implementação-em-hardware-arquitetura-de-memória">Implementação em <em>Hardware</em>: Arquitetura de Memória</a></h3>
<ul>
<li>Memória do Dispositivo (DRAM):
<ul>
<li>Lenta (2 a 300 ciclos);</li>
<li>Em memória local, global, constante ou de textura.</li>
</ul>
</li>
<li><em>On-chip memory</em>:
<ul>
<li>Rápida (1 ciclo);</li>
<li>Registos, memória partilha e <em>cache</em> de constantes/texturas.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter_6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter_6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
